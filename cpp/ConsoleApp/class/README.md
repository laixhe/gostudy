> 类的大小计算的时候，只包括：
> >
> > 1. 类的非静态成员数据的类型大小之和
> >
> > 2. 如果有虚函数的话，还要加上指向虚函数表指针(vptr)大小(4字节或8字节)，指向一个虚函数表(函数指针数组)
> >
> > 3. 与类中的构造函数，析构函数以及其他的成员函数无关
> >

> 空类、空结构体、类中只有成员函数，没有变量，点用空间大小都是1(因为每一个对象实现化都需要空间的)

> 虚函数表指针
> >
> > 子类继承父类不重写虚函数: 虚函数表存放就是父类的虚函数地址
> >
> > 子类继承父类重写虚函数: 虚函数表存放的是自已的虚函数地址
> >

> 成员方法(函数)为什么不占用对象的空间
> >
> > 只用一段空间来存放这个共同的函数代码段，在调用各对象的函数时，都去调用这个公用的函数代码(所有类成员函数和非成员函数代码存放在代码区)
> >
> > 因此每个对象所占用的存储空间只是该对象的数据部分（虚函数指针和虚基类指针也属于数据部分）所占用的存储空间，而不包括函数代码所占用的存储空间
> >

> this 指定对象本身的指针(对象的首地址)，不占用对象的内存空间大小
```
# this 是编译器帮我们生成的

# 我们写的
class xxx {
    void a(){}
}
# 我们调用的
xxx x;
x.a();

# 编译器生成(可能)
class xxx{
    void a(xxx *this){}
}
# 调用被编译器生成(可能)
xxx x;
x.a(&x);
```

##### override(重写) [C++11]
> 基类函数必须有 virtual 关键字

##### delete(删除函数) [C++11]
> 有的时候，我们的类不想支持拷贝构造函数和赋值构造函数，使用 `=delete` 来将赋值函数和拷贝构造函数设置为删除函数，这样的话无论什么函数都无法调用删除函数