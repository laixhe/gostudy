`Go语言`的对齐规则与`C语言`一样

> 对齐系数
- `32位`系统对齐系数是 `4`
- `64位`系统对齐系数是 `8`

> 对齐规则
- `规则1`: 结构体的各个成员，第一个成员位于偏移为`0`的位置，结构体第一个成员的偏移量(offset)为`0`，以后每个成员相对于结构体首地址的`offset`都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节
- `规则2`: 结构成员需要对齐，结构本身也需要对齐，结构的长度必须是编译器默认的对齐长度和成员中最长类型中最小的数据大小的倍数对齐

> 例子
```
type User struct {
 A int32    // 4
 B []int32  // 24
 C string   // 16
 D bool     // 1
}

func main()  {
   var u User
   fmt.Println("u size is ", unsafe.Sizeof(u))
}
// 运行结果
u size is 56
```

`64位`平台，对齐参数是`8`，`int32`、`[]int32`、`string`、`bool`对齐值分别是`4`、`8`、`8`、`1`，占用内存大小分别是`4`、`24`、`16`、`1`

> 根据`规则1`分析
- 第一个字段类型是`int32`，对齐值是`4`，大小为`4`，所以放在内存布局中的第一位
- 第二个字段类型是`[]int32`，对齐值是`8`，大小为`24`，按照第一条规则，偏移量应该是成员大小`24`与对齐值`8`中较小那个的整数倍，那么偏移量就是`8`，所以`4-7`位会由编译进行填充，一般为`0`值，也称为空洞，第`9`到`32`位为第二个字段`B`
- 第三个字段类型是`string`，对齐值是`8`，大小为`16`，所以他的内存偏移值必须是`8`的倍数，因为`user`前两个字段就已经排到了第`32`位，所以`offset`为`32`正好是`8`的倍数，不要填充，从`3`2位到`48`位是第三个字段`C`
- 第四个字段类型是`bool`，对齐值是`1`，大小为`1`，所以他的内存偏移值必须是`1`的倍数，因为`user`前两个字段就已经排到了第`48`位，所以下一位的偏移量正好是`48`，正好是字段`D`的对齐值的倍数，不用填充，可以直接排列到第四个字段，也就是从`48`到第`49`位是第三个字段`D`

> 根据`规则2`分析
- 根据`规则2`，默认对齐值是`8`，字段中最大类型程度是`24`，所以求出结构体的对齐值是`8`，我们目前的内存长度是`49`，不是`8`的倍数，所以需要补齐，所以最终的结果就是`56`补了`7`位

> 总结分析
- 第一个字段，需要补齐 4 位
- 第四个字段，需要补齐 7 位


### 成员变量顺序对内存对齐带来的影响
```
type test1 struct {
 a bool   // 1
 b int32  // 4
 c string // 16
}

type test2 struct {
 a int32  // 4
 b string // 16
 c bool   // 1
}


func main()  {
 var t1 test1
 var t2 test2

 fmt.Println("t1 size is ",unsafe.Sizeof(t1))
 fmt.Println("t2 size is ",unsafe.Sizeof(t2))
}

// 运行结果
t1 size is  24
t2 size is  32
```

### 空结构体字段对齐
> 在 `Go语言` 中空结构体的大小为`0`，如果一个结构体中包含空结构体类型的字段时，通常是不需要进行内存对齐的

